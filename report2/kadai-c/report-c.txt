以下のコマンドによって500KB程度のファイルsourcefileをつくった。
$ dd if=/dev/zero of=sourcefile bs=1024 count=500

その後、measure1とmeasure2を実行した。

$ ./measure1
 one byte  : 0.609066290 sec
8192 bytes : 0.000303895 sec

$ ./measure2
 one byte  : 0.015437945 sec
8192 bytes : 0.000122690 sec



　measure1の実行結果から、バッファサイズを大きくするとより高速にファイルのコピーが可能になることがわかる。実行速度のオーダーもバッファサイズに反比例して大きくなっている。また、measure2の実行結果と比較すると、高水準出力関数を使うと低水準出力関数を使うより高速にファイルのコピーが可能になることがわかる。高水準出力関数を使った場合では実行速度のオーダーはバッファサイズに反比例しているわけではなく、バッファサイズが大きくなっても低水準出力関数を使ったときよりも高速化は進んでいない。

　これは高水準出力関数では内部にバッファをもっているため、引数のバッファサイズを変更しても実際にシステムコールを行う際には違うバッファサイズを使って実行されているためだと考えられる。低水準出力関数では引数によって実際に使われるバッファサイズを直接変更できるが、高水準出力関数では内部のバッファサイズを変更しなければならないと思われる。



strace関数を用いて、バッファサイズを１バイトにしているときのシステムコールの様子を調査した。

$ strace ./measure1

...
write(4, "\0", 1)                       = 1
read(3, "\0", 1)                        = 1
write(4, "\0", 1)                       = 1
read(3, "\0", 1)                        = 1
write(4, "\0", 1)                       = 1
...

$ strace ./measure2

...
read(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
write(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
read(3, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
write(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
...

結果は上記のようになり、低水準出力関数を用いたときは1バイトずつシステムコールが呼び出されるのに比べて、高水準出力を用いたときにはある程度まとまったバイトが溜まってから一気にシステムコールを呼び出している。



また、setvbuf関数を使って、高水準出力関数が内部でバッファをつかわないように設定し、同様に１バイトと8192バイトずつコピーする実行速度を計測するファイルmeasure3を作成し、実行した。

$ ./measure3
  1 bytes : 0.791409088 sec
8192 bytes: 0.000225397 sec

これはmeasure1を実行して、低水準出力関数を用いてコピーを行ったときと同様に、バッファサイズのオーダーと実行時間が反比例している。



以上から高水準出力関数では内部でバッファを用いており、単純に引数のバッファサイズを変えただけでは実行時間は大きく変化しないが、setvbufにより内部のバッファサイズを変更できるということがわかった。
